# Copyright (c) HashiCorp, Inc.
# SPDX-License-Identifier: MPL-2.0
name: hashicorp/field-workshops-consul/nightly-test
on:
  workflow_dispatch:
  schedule:
  # This is UTC
  - cron: 37 4 * * *
permissions:
  contents: read
env:
  # See IL-559 for information about the source of these
  # secrets and variables
  # You MUST base64 encode the GCLOUD_SERVICE_KEY json blob, otherwise
  # GHA in being zealous about redacting secrets will turn the `needs`
  # context json we require in the Slack notification steps will turn 
  # curly braces into '***'
  GCLOUD_SERVICE_KEY_JSON_BASE64: ${{ secrets.GCLOUD_SERVICE_KEY_JSON_BASE64 }}
  GOOGLE_COMPUTE_REGION: ${{ vars.GOOGLE_COMPUTE_REGION }}
  GOOGLE_PROJECT_ID: ${{ vars.GOOGLE_PROJECT_ID }}
  INSTRUQT_TOKEN: ${{ secrets.INSTRUQT_TOKEN }}
jobs:
  # This should be changed long term: we build a new container
  # every night even though the majority of the time nothing changes.
  # Figure out a way to trigger only when the source changes, or
  # the configuration changes
  update-cloud-client:
    runs-on: ubuntu-latest
    permissions: {}
    # We add this output and set it to 1 to match all the other
    # tests, so we don't have to special case this job
    outputs:
      test_runs: 1
    env:
      # See IL-559 for information about the setting of these
      # variables
      PACKER_VERSION: ${{ vars.PACKER_VERSION }}
      TF_VERSION: ${{ vars.TF_VERSION }}
      VAULT_VERSION: ${{ vars.VAULT_VERSION }}
      NOMAD_VERSION: ${{ vars.NOMAD_VERSION }}
      CONSUL_VERSION: ${{ vars.CONSUL_VERSION }}
      CONSUL_TAG: ${{ vars.CONSUL_TAG }}
      ENVOY_VERSION: ${{ vars.ENVOY_VERSION }}
    steps:
      - name: bogus
        run: exit 0
      - name: Checkout Source
        id: checkout-source
        uses: actions/checkout@f43a0e5ff2bd294095638e18286ca9a3d1956744 # v3.6.0
        with:
          repository: hashicorp/instruqt-packer
          token: ${{ secrets.HC_GITHUB_SOLUTIONS_ENGINEERING_PAT }}
          path: instruqt-packer
          ref: ${{ vars.CONSUL_CLOUD_CLIENT_REF }}  # The ref in the repo we are targeting
      - name: Write GCloud Key
        id: write-gcloud-key
        run: echo "${GCLOUD_SERVICE_KEY_JSON_BASE64}" | base64 -d > "${HOME}"/gcloud.json
      - name: Auth to GCP
        id: auth-to-gcp
        run: gcloud auth activate-service-account --key-file="${HOME}/gcloud.json" --project "${GOOGLE_PROJECT_ID}"
      - name: Configure Docker
        id: configure-docker
        run: |-
          gcloud auth configure-docker
          gcloud config set project "${GOOGLE_PROJECT_ID}"
      - name: Build container
        id: build-container
        run: docker build --build-arg PACKER_VERSION="${PACKER_VERSION}" --build-arg TF_VERSION="${TF_VERSION}" --build-arg VAULT_VERSION="${VAULT_VERSION}" --build-arg NOMAD_VERSION="${NOMAD_VERSION}" --build-arg CONSUL_VERSION="${CONSUL_VERSION}" --build-arg ENVOY_VERSION="${ENVOY_VERSION}" -f instruqt-packer/consul-cloud-client-no-license/Dockerfile -t gcr.io/"${GOOGLE_PROJECT_ID}"/consul-cloud-client-no-license:"${CONSUL_TAG}" instruqt-packer/consul-cloud-client-no-license
      - name: Push container
        id: push-container
        run: docker push gcr.io/"${GOOGLE_PROJECT_ID}"/consul-cloud-client-no-license:"${CONSUL_TAG}"
  consul-basics:
    uses: ./.github/workflows/instruqt-track-test.yml
    with:
      working_directory: "instruqt-tracks/consul-basics"
      INSTRUQT_CLI_URI: ${{ vars.INSTRUQT_CLI_URI }}
    secrets:
      INSTRUQT_TOKEN: ${{ secrets.INSTRUQT_TOKEN }}
  service-discovery-with-consul:
    uses: ./.github/workflows/instruqt-track-test.yml
    with:
      working_directory: "instruqt-tracks/service-discovery-with-consul"
      INSTRUQT_CLI_URI: ${{ vars.INSTRUQT_CLI_URI }}
    secrets:
      INSTRUQT_TOKEN: ${{ secrets.INSTRUQT_TOKEN }}
  service-mesh-with-consul:
    uses: ./.github/workflows/instruqt-track-test.yml
    with:
      working_directory: "instruqt-tracks/service-mesh-with-consul"
      INSTRUQT_CLI_URI: ${{ vars.INSTRUQT_CLI_URI }}
    secrets:
      INSTRUQT_TOKEN: ${{ secrets.INSTRUQT_TOKEN }}
  multi-cloud-consul:
    uses: ./.github/workflows/instruqt-track-test.yml
    needs: update-cloud-client
    with:
      working_directory: "instruqt-tracks/multi-cloud-service-networking-with-consul"
      INSTRUQT_CLI_URI: ${{ vars.INSTRUQT_CLI_URI }}
    secrets:
      INSTRUQT_TOKEN: ${{ secrets.INSTRUQT_TOKEN }}
  network-infrastructure-automation:
    uses: ./.github/workflows/instruqt-track-test.yml
    with:
      working_directory: "instruqt-tracks/network-infrastructure-automation"
      INSTRUQT_CLI_URI: ${{ vars.INSTRUQT_CLI_URI }}
    secrets:
      INSTRUQT_TOKEN: ${{ secrets.INSTRUQT_TOKEN }}
  life-of-a-developer:
    uses: ./.github/workflows/instruqt-track-test.yml
    with:
      working_directory: "instruqt-tracks/consul-life-of-a-developer"
      INSTRUQT_CLI_URI: ${{ vars.INSTRUQT_CLI_URI }}
    secrets:
      INSTRUQT_TOKEN: ${{ secrets.INSTRUQT_TOKEN }}
  notify-slack:
    needs:
      - update-cloud-client
      - consul-basics
      - service-discovery-with-consul
      - service-mesh-with-consul
      - multi-cloud-consul
      - network-infrastructure-automation
      - life-of-a-developer
    if: ${{ always() }}   # Always run after needs, even if they failed, so we can notify
    runs-on: ubuntu-latest
    permissions: {}
    steps:
      # https://github.com/actions/runner/issues/1656#issuecomment-1030077729
      - name: Get Jobs State
        id: get-jobs-state
        run: |-
          cat<<"EOF" >> job-state.json
          ${{ toJSON(needs) }}
          EOF
      - name: Build Message
        id: build-message
        shell: python
        run: |-
          import json
          import os
          import secrets
          msg = {"blocks": []}
          # Parse 'needs' context
          needs_f = open("job-state.json")
          needs = json.load(needs_f)
          # Header Section
          WORKFLOW_ICON=":white_check_mark:"
          WORKFLOW_STATUS="successful"
          ANY_FAILURES=False
          for job in needs.keys():
            if needs[job]['result'] != "success":
              WORKFLOW_ICON=":exclamation:"
              WORKFLOW_STATUS="*FAILED*"
              ANY_FAILURES=True
              break
          msg['blocks'].append({"type": "section", "text": { "type": "mrkdwn", "text": f'{WORKFLOW_ICON} Workflow <${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|${{ github.workflow }} #${{ github.run_number }}> {WORKFLOW_STATUS}'}})
          msg['blocks'].append({"type": "divider"})

          # Per-job section
          for job in needs.keys():
            if needs[job]['result'] == "success":
              TEST_ICON=":white_check_mark:"
              TEST_STATUS="succeeded"
            else:
              TEST_ICON=":exclamation:"
              TEST_STATUS="*FAILED*"

            TEST_RUNS=int(needs[job]['outputs']['test_runs'])
            if TEST_RUNS == 1:
              TEST_RUN_STRING="run"
            else:
              TEST_RUN_STRING="runs"

            job_msg = {"type": "section", "text": { "type": "mrkdwn", "text": f'{TEST_ICON} {job}: {TEST_STATUS} in {TEST_RUNS} {TEST_RUN_STRING}'}}
            msg['blocks'].append(job_msg)

          # Output
          # https://trstringer.com/github-actions-multiline-strings/ Option 2
          # NOTE: Where we typically use 'EOF' as a heredoc delimiter, following
          # the security advice in
          # https://docs.github.com/en/actions/using-workflows/workflow-commands-for-github-actions#multiline-strings
          # we generate a random delimiter every time
          EOF = secrets.token_hex(24)
          env = open('${{ github.env }}', mode='a')
          env.writelines([f'SLACK_PAYLOAD<<{EOF}\n'])
          json.dump(msg, env)
          env.writelines([f'\n{EOF}\n'])
          env.close()
          # And output if there have been any failures - there doesn't
          # seem to be an equivalent github context for this, so have to
          # read GITHUB_OUTPUT out of os.environ
          output = open(os.environ['GITHUB_OUTPUT'], mode='a')
          if ANY_FAILURES:
            output.writelines(['any_failures=true\n'])
          else:
            output.writelines(['any_failures=false\n'])
          output.close()
      - name: Post to Slack Channel
        id: slack
        uses: slackapi/slack-github-action@e28cf165c92ffef168d23c5c9000cffc8a25e117 # v1.24.0
        with:
          channel-id: ${{ vars.SLACK_NOTIFICATION_CHANNELS }}
          payload: ${{ env.SLACK_PAYLOAD }}
        env:
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
      - name: Post to Slack Channel only on failures
        id: slack-failures
        if: ${{ steps.build-message.outputs.any_failures == 'true' }}
        uses: slackapi/slack-github-action@e28cf165c92ffef168d23c5c9000cffc8a25e117 # v1.24.0
        with:
          channel-id: ${{ vars.SLACK_NOTIFICATION_CHANNELS_FAIL_ONLY }}
          payload: ${{ env.SLACK_PAYLOAD }}
        env:
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
