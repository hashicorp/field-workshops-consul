# Copyright (c) HashiCorp, Inc.
# SPDX-License-Identifier: MPL-2.0
name: hashicorp/field-workshops-consul/nightly-test
on:
  workflow_dispatch:
  schedule:
  # This is UTC
  - cron: 37 4 * * *
permissions:
  contents: read
env:
  # See IL-559 for information about the source of these
  # secrets and variables
  GCLOUD_SERVICE_KEY: ${{ secrets.GCLOUD_SERVICE_KEY }}
  GOOGLE_COMPUTE_REGION: ${{ vars.GOOGLE_COMPUTE_REGION }}
  GOOGLE_PROJECT_ID: ${{ vars.GOOGLE_PROJECT_ID }}
  HC_CONSUL_LICENSE: ${{ secrets.HC_CONSUL_LICENSE }}
  HC_VAULT_LICENSE: ${{ secrets.HC_VAULT_LICENSE }}
  INSTRUQT_TOKEN: ${{ secrets.INSTRUQT_TOKEN }}
jobs:
  # This should be changed long term: we build a new container
  # every night even though the majority of the time nothing changes.
  # Figure out a way to trigger only when the source changes, or
  # the configuration changes
  license-cloud-client:
    runs-on: ubuntu-latest
    permissions: {}
    # We add this output and set it to 1 to match all the other
    # tests, so we don't have to special case this job
    outputs:
      test_runs: 1
    env:
      # See IL-559 for information about the setting of these
      # variables
      PACKER_VERSION: ${{ vars.PACKER_VERSION }}
      TF_VERSION: ${{ vars.TF_VERSION }}
      VAULT_VERSION: ${{ vars.VAULT_VERSION }}
      NOMAD_VERSION: ${{ vars.NOMAD_VERSION }}
      CONSUL_VERSION: ${{ vars.CONSUL_VERSION }}
      CONSUL_TAG: ${{ vars.CONSUL_TAG }}
      ENVOY_VERSION: ${{ vars.ENVOY_VERSION }}
    steps:
      - name: bogus
        run: exit 0
##     - name: Checkout Source
##       id: checkout-source
##       uses: actions/checkout@ac593985615ec2ede58e132d2e21d2b1cbd6127c
##       with:
##         repository: hashicorp/instruqt-packer
##         token: ${{ secrets.HC_GITHUB_SOLUTIONS_ENGINEERING_PAT }}
##         path: instruqt-packer
##         ref: ${{ vars.CONSUL_CLOUD_CLIENT_REF }}  # The ref in the repo we are targeting
##     - name: Write GCloud Key
##       id: write-gcloud-key
##       run: echo "${GCLOUD_SERVICE_KEY}" > "${HOME}"/gcloud.json
##     - name: Auth to GCP
##       id: auth-to-gcp
##       run: gcloud auth activate-service-account --key-file="${HOME}/gcloud.json" --project "${GOOGLE_PROJECT_ID}"
##     - name: Configure Docker
##       id: configure-docker
##       run: |-
##         gcloud auth configure-docker
##         gcloud config set project "${GOOGLE_PROJECT_ID}"
##     - name: Build container
##       id: build-container
##       run: docker build --build-arg HC_VAULT_LICENSE="${HC_VAULT_LICENSE}" --build-arg HC_CONSUL_LICENSE="${HC_CONSUL_LICENSE}" --build-arg PACKER_VERSION="${PACKER_VERSION}" --build-arg TF_VERSION="${TF_VERSION}" --build-arg VAULT_VERSION="${VAULT_VERSION}" --build-arg NOMAD_VERSION="${NOMAD_VERSION}" --build-arg CONSUL_VERSION="${CONSUL_VERSION}" --build-arg ENVOY_VERSION="${ENVOY_VERSION}" -f instruqt-packer/consul-cloud-client/Dockerfile -t gcr.io/"${GOOGLE_PROJECT_ID}"/consul-cloud-client:"${CONSUL_TAG}" instruqt-packer/consul-cloud-client
##     - name: Push container
##       id: push-container
##       run: docker push gcr.io/"${GOOGLE_PROJECT_ID}"/consul-cloud-client:"${CONSUL_TAG}"
  consul-basics:
    uses: ./.github/workflows/instruqt-track-test.yml
    with:
      working_directory: "instruqt-tracks/consul-basics"
      INSTRUQT_CLI_URI: ${{ vars.INSTRUQT_CLI_URI }}
    secrets:
      INSTRUQT_TOKEN: ${{ secrets.INSTRUQT_TOKEN }}
  service-discovery-with-consul:
    uses: ./.github/workflows/instruqt-track-test.yml
    with:
      working_directory: "instruqt-tracks/service-discovery-with-consul"
      INSTRUQT_CLI_URI: ${{ vars.INSTRUQT_CLI_URI }}
    secrets:
      INSTRUQT_TOKEN: ${{ secrets.INSTRUQT_TOKEN }}
  service-mesh-with-consul:
    uses: ./.github/workflows/instruqt-track-test.yml
    with:
      working_directory: "instruqt-tracks/service-mesh-with-consul"
      INSTRUQT_CLI_URI: ${{ vars.INSTRUQT_CLI_URI }}
    secrets:
      INSTRUQT_TOKEN: ${{ secrets.INSTRUQT_TOKEN }}
  multi-cloud-consul:
    uses: ./.github/workflows/instruqt-track-test.yml
    needs: license-cloud-client
    with:
      working_directory: "instruqt-tracks/multi-cloud-service-networking-with-consul"
      INSTRUQT_CLI_URI: ${{ vars.INSTRUQT_CLI_URI }}
    secrets:
      INSTRUQT_TOKEN: ${{ secrets.INSTRUQT_TOKEN }}
  network-infrastructure-automation:
    uses: ./.github/workflows/instruqt-track-test.yml
    with:
      working_directory: "instruqt-tracks/network-infrastructure-automation"
      INSTRUQT_CLI_URI: ${{ vars.INSTRUQT_CLI_URI }}
    secrets:
      INSTRUQT_TOKEN: ${{ secrets.INSTRUQT_TOKEN }}
  life-of-a-developer:
    uses: ./.github/workflows/instruqt-track-test.yml
    with:
      working_directory: "instruqt-tracks/consul-life-of-a-developer"
      INSTRUQT_CLI_URI: ${{ vars.INSTRUQT_CLI_URI }}
    secrets:
      INSTRUQT_TOKEN: ${{ secrets.INSTRUQT_TOKEN }}
  notify-slack:
    needs:
      - license-cloud-client
      - consul-basics
      - service-discovery-with-consul
      - service-mesh-with-consul
      - multi-cloud-consul
      - network-infrastructure-automation
      - life-of-a-developer
    if: ${{ always() }}   # Always run after needs, even if they failed, so we can notify
    runs-on: ubuntu-latest
    steps:
      # https://github.com/actions/runner/issues/1656#issuecomment-1030077729
      - name: Get Jobs State
        id: get-jobs-state
        run: |-
          cat<<EOF >> job-state.json
          ${{ toJSON(needs) }}
          EOF
          cat job-state.json
      - name: Build Message
        id: build-message
        shell: python
        run: |-
          import json
          import secrets
          msg = {"blocks": []}
          # Parse 'needs' context
          needs_f = open("job-state.json")
          needs = json.load(needs_f)
          # Header Section
          WORKFLOW_ICON=":white_check_mark:"
          WORKFLOW_STATUS="successful"
          for job in needs.keys():
            if needs[job]['result'] != "success":
              WORKFLOW_ICON=":exclamation:"
              WORKFLOW_STATUS="*FAILED*"
              break
          msg['blocks'].append({"type": "section", "test": { "type": "mrkdwn", "text": f'{WORKFLOW_ICON} Workflow <${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|${{ github.repository }}/${{ github.workflow }} #${{ github.run_id }}> {WORKFLOW_STATUS}'}})
          msg['blocks'].append({"type": "divider"})

          # Per-job section
          for job in needs.keys():
            if needs[job]['result'] == "success":
              TEST_ICON=":white_check_mark:"
              TEST_STATUS="succeeded"
            else:
              TEST_ICON=":exclamation:"
              TEST_STATUS="*FAILED*"

            TEST_RUNS=needs[job]['outputs']['test_runs']
            if TEST_RUNS == 1:
              TEST_RUN_STRING="run"
            else:
              TEST_RUN_STRING="runs"

            job_msg = {"type": "section", "test": { "type": "mrkdwn", "text": f'{TEST_ICON} {job}: {TEST_STATUS} in {TEST_RUNS} {TEST_RUN_STRING}'}}
            msg['blocks'].append(job_msg)

          # Output
          # https://trstringer.com/github-actions-multiline-strings/ Option 2
          # NOTE: Where we typically use 'EOF' as a heredoc delimiter, following
          # the security advice in
          # https://docs.github.com/en/actions/using-workflows/workflow-commands-for-github-actions#multiline-strings
          # we generate a random delimiter every time
          EOF = secrets.token_hex(24)
          env = open('${{ github.env }}', mode='a')
          env.writelines([f'SLACK_MESSAGE<<{EOF}\n'])
          json.dump(msg, env)
          env.writelines([f'{EOF}\n'])
          env.close()
      - name: Post to Slack Channel
        id: slack
        uses: slackapi/slack-github-action@007b2c3c751a190b6f0f040e47ed024deaa72844 # v1.23.0
        with:
          channel-id: ${{ vars.SLACK_NOTIFICATION_CHANNELS }}
          slack-message: ${{ env.SLACK_MESSAGE }}
        env:
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
