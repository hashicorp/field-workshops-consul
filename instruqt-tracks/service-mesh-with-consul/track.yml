slug: service-mesh-with-consul
id: bok4pw0xdfdr
type: track
title: Service Mesh with Consul
teaser: Evolve from service discovery to service mesh. No more mapping IP addresses
  and ports across load balancers and firewalls. Consul Connect ensures secure connections
  between services wherever they run.
description: |-
  This track will build on what you learned in the service discovery track and take our application from service discovery to service mesh.
  We'll dive into mesh fundamentals and use an Envoy proxy to connect our application to its database.
icon: https://storage.googleapis.com/instruqt-frontend/assets/hashicorp/tracks/consul.png
tags: []
owner: hashicorp
developers:
- lance@hashicorp.com
- scarolan@hashicorp.com
private: false
published: true
maintenance: false
challenges:
- slug: sidecar-services
  id: 4zvgi4rkfawl
  type: challenge
  title: "Get Into My Sidecar \U0001F697"
  teaser: Create a sidecar service defintion for your application proxy
  assignment: "In this challenge we'll add a sidecar service to our existing service
    defintion. <br>\n\nThe `sidecar_service` field is a nested service definition
    where almost any regular service definition field can be set.  \n\nAll fields
    in the nested definition are optional, however there are some default settings
    that make sidecar proxy configuration much simpler.  \n\nIn orchestrated environments,
    such as `Kubernetes` or `Nomad`, this is highly abstract and can be configured
    with simple metadata i.e. annotations. We'll explore this more in the next topic
    track.\n\nUpdate the defintion by adding the the `connect` block as seen below.
    Copy and paste what's below over the entire file in the *Database Service* tab.
    Use CTRL-S to save the file.\n\n```\n{\n  \"service\": {\n    \"name\": \"mysql\",\n
    \   \"tags\": [\n      \"database\",\n      \"production\"\n    ],\n    \"port\":
    3306,\n    \"connect\": { \"sidecar_service\": {} },\n    \"check\": {\n      \"id\":
    \"mysql\",\n      \"name\": \"MySQL TCP on port 3306\",\n      \"tcp\": \"localhost:3306\",\n
    \     \"interval\": \"10s\",\n      \"timeout\": \"1s\"\n    }\n  }\n}\n```\n\nNext,
    reload Consul:\n\n```\nconsul reload\n```\n\nYou should see a failing service
    called `mysql-sidecar-proxy` in Consul. This is expected!  \n\nWe will start a
    proxy and register it with Connect in our next challenge.  "
  notes:
  - type: text
    contents: "Connect proxies are typically deployed as \"sidecars\" to an instance
      that they handle traffic for. They might be on the same bare metal server, virtual
      machine, or Kubernetes daemonset. Connect has a plugable proxy architecture,
      with awesome first-class support for Envoy. We'll use Envoy as our proxy for
      the entirety of this workshop. \n\nVisit the [Connect docs](https://www.consul.io/docs/connect/proxies.html)
      for more info on proxy integration.  \n\nIn this challenge, we'll set up a sidecar
      defintion."
  - type: image
    url: https://github.com/hashicorp/field-workshops-consul/blob/master/docs/oss/images/connect_sidecar.png?raw=true
  tabs:
  - title: Consul UI
    type: service
    hostname: consul-server-0
    port: 8500
  - title: Database
    type: terminal
    hostname: database
  - title: Database Service
    type: code
    hostname: database
    path: /consul/config/database_service.json
  difficulty: basic
  timelimit: 900
- slug: sidecar-proxies
  id: l8hfdudhif7b
  type: challenge
  title: "Introducing the Envoy Proxy \U0001F5A7"
  teaser: Run your first Connect sidecar proxy with Envoy
  assignment: "Now that we've registered a proxy service in Consul for our MySQL database,
    let's start the proxy server so the health check will pass.\nConsul will bootstrap
    the proxy with the correct configuration, and bring it into the mesh for us.  \n\nWe've
    placed an Envoy binary on this machine for you. Consul will be able to access
    it from the `$PATH.`  \n\nGo ahead and start the proxy with the following command:\n\n```\nnohup
    consul connect envoy -sidecar-for mysql > /envoy.out &\n```\n\nYou can verify
    in the Consul UI or the with the Consul CLI that your proxy health check is now
    passing.  \n\nWe can now use the proxy to establish communication between our
    application and the database!"
  notes:
  - type: text
    contents: "In the last challenge we set up a sidecar service defintion for our
      Envoy proxy. This is the first step in bringing our mesh to life.\nThe sidecar
      defintion tells Consul to expect a proxy registration for a service, Database,
      in this example.  \n\nNow that Consul is aware that the Database service should
      run a proxy, we can use the Consul agent to boostrap the proxy and send it dynamic
      \ configuraiton.  \n\nWe'll take a deeper look at this configuration later."
  tabs:
  - title: Consul UI
    type: service
    hostname: consul-server-0
    port: 8500
  - title: Database
    type: terminal
    hostname: database
  - title: Database Service
    type: code
    hostname: database
    path: /consul/config/database_service.json
  difficulty: basic
  timelimit: 900
- slug: sidecar-upstreams
  id: 7vynj1nfnnan
  type: challenge
  title: "Connect Upstream with Envoy \U0001F517"
  teaser: Add an upstream defintion for our Envoy app proxy
  assignment: "We've brought back our application server for this assignment.  \n\nIt
    has an empty sidecar_service defintion, which you can see in the code editior.
    \ \n\nLet's modify it below to create connectivity to our database.  \n\nModify
    the application's `sidecar_service` defintion to add our upstream for the database.
    You can copy and paste the entire file from below:\n\n```\n{\n  \"service\": {\n
    \   \"name\": \"wordpress\",\n    \"tags\": [\n      \"wordpress\",\n      \"production\"\n
    \   ],\n    \"port\": 80,\n    \"connect\": {\n      \"sidecar_service\": {\n
    \       \"proxy\": {\n          \"upstreams\": [\n            {\n              \"destination_name\":
    \"mysql\",\n              \"local_bind_port\": 3306\n            }\n          ]\n
    \       }\n      }\n    },\n    \"check\": {\n      \"id\": \"wordpress\",\n      \"name\":
    \"wordpress TCP on port 80\",\n      \"tcp\": \"localhost:80\",\n      \"interval\":
    \"10s\",\n      \"timeout\": \"1s\"\n    }\n  }\n}\n```\n\nNext, reload Consul.
    \ \n\n```\nconsul reload\n```\n\nEnvoy will create a loopback listener for us
    to connect to the database on port `3306`.  \n\nEnvoy has an admin interface that
    listens on port `19000` by default.\nWe can check out our new listener with following
    command.  \n\n```\ncurl localhost:19000/listeners\n```\n\nWe'll configure our
    application to use the listener in our next assignment.  "
  notes:
  - type: text
    contents: "\nConnect provides service connectivity through upstream defintions.\nThese
      services could be a database, backend, or any service which another service
      relies on.  \n\nIn the previous challenges we set up a sidecar service defintion
      without an upstream defintion.  \n\nIn this assignment we'll modify our sidecar
      service and add an upstream defintion that will allow our application to connect
      to its database."
  tabs:
  - title: Consul UI
    type: service
    hostname: consul-server-0
    port: 8500
  - title: App
    type: terminal
    hostname: app
  - title: App Service
    type: code
    hostname: app
    path: /consul/config/application_service.json
  difficulty: basic
  timelimit: 900
- slug: enable-localhost-proxy
  id: tymg5yhlxjgb
  type: challenge
  title: "Enter the Meshtrix \U0001F469\U0001F3FB‍\U0001F4BB"
  teaser: Use Consul and Envoy to connect our application to a backend database
  assignment: "In the last assignment we created an Envoy listener for our database
    service through a Connect upstream defintion.\nLet's use that defintion to allow
    our application to connect to the database.  \n\nRemember, our listener is configured
    on localhost, so we can just update our properties file to `127.0.0.1`, and establish
    connectivity. \n\nGo ahead and do this now. Check the `Website` tab. Our service mesh
    blog is back online!"
  notes:
  - type: text
    contents: In this section will use Envoy to connect the application to the database.
  tabs:
  - title: Consul UI
    type: service
    hostname: consul-server-0
    port: 8500
  - title: App
    type: terminal
    hostname: app
  - title: App Config
    type: code
    hostname: app
    path: /var/www/html/wp-config.php
  - title: Website
    type: service
    hostname: app
    port: 80
  difficulty: basic
  timelimit: 900
- slug: open-and-close-the-gates
  id: d3mqrfaegmle
  type: challenge
  title: "Open and Close the Gates \U0001F511\U0001F6AA"
  teaser: Use Consul intentions to allow or deny proxy traffic based on application
    service identity.
  assignment: "Traffic is denied by default at the start of this assignment, so our
    application is now broken.  \nLet's create an allow rule to bring back our application.
    Copy the following command into the *app* tab.  \n\n```\nconsul intention create
    -allow wordpress mysql\n```\n\nYou can also manage Intentions in the `Intentions`
    tab of the Consul UI.  \n\nClick on the intention, and change it to `deny`.  What
    happens?\n\nChange it back to `allow` to restore service. With connectivity from
    the database restored, your application should be serving traffic once again!!!
    \ \n\nWe'll dive deeper into how this works in the next challenge."
  notes:
  - type: text
    contents: Intentions define access control for services via Consul Connect and
      are used to control which services may establish connections. You can manage
      Intentions via the API, CLI, or UI. Intentions are enforced by the proxy on
      inbound connections.
  - type: text
    contents: "After verifying the TLS client certificate, the authorized API endpoint
      is called which verifies the connection.  \n\nIf authorize returns false the
      connection must be terminated.  \n\nIntentions are powerful because they free
      you from having to manage endless lists of IP address and port mappings.\n\n
      Instead, we can manage traffic in simple terms by what an application is or
      does. \n\nLet's use intentions to restrict connectivity from our applciaiton
      to the database."
  tabs:
  - title: Consul UI
    type: service
    hostname: consul-server-0
    port: 8500
  - title: app
    type: terminal
    hostname: app
  - title: Website
    type: service
    hostname: app
    port: 80
  difficulty: basic
  timelimit: 900
- slug: sidecar-envoy
  id: ntf48xx67xaz
  type: challenge
  title: Pop Open the Hood ⚙️
  teaser: Peek inside and learn some Envoy & Consul magic
  assignment: |-
    First, let's check out some of the certificate information from our Envoy proxy.
    You can see some basic cert info in the Envoy UI under `certs`.
    We've also grabbed the cert for you and decoded in the code editor. <br>

    We can look some basic certificate information from Envoy with the below command.
    ```
    curl -s localhost:19000/certs | jq '.certificates[0].cert_chain[0].subject_alt_names[0].uri'
    ```
    Nice! That's the identity for our application in the mesh. We can see the TTL for the certificate

    Let's see when that  cert expires.
    ```
    curl -s localhost:19000/certs | jq '.certificates[0].cert_chain[0].days_until_expiration'
    ```
    Our certificate TTL is very short, 2 days! And as a bonus, it's automatically managed by Consul. <br>

    Second, let's check out some of the service discovery information from our Envoy proxy. You can see the this in the Envoy UI under `clusters`.

    ```
    curl -s localhost:19000/clusters | grep  mysql
    ```

    We can see the `added_via_api::true` is set for our `database` cluster, which means the Consul agent sent this to Envoy via the API.
    We can also validate that the ip address in Envoy matches the ip address in Consul for the database node.

    ```
    curl -s  http://127.0.0.1:8500/v1/catalog/node/Database | jq '.Node.Address'
    ```

    Last, we can do some basic intention validation by emulating the API call made from Envoy to  the Consul agent.

    ```
    curl -s -X POST -d @/tmp/payload.json http://127.0.0.1:8500/v1/agent/connect/authorize |  jq
    ```

    That's it!!! Now you're an expert at troubleshooting Connect & Envoy!!!
  notes:
  - type: text
    contents: |-
      In this assignment, we'll take a deeper look at Envoy. We'll focus on three elements that make up the foundation of our mesh. <br>

      * mTLS - How did Connect and Envoy provide end-to-end encryption between services ?
      * Service Discovery - How was Consul able to get service discovery information to the Envoy proxy for it's upstreams?
      * Intentions - How were we able to allow or deny traffic based on service identity ?

      Let's investigate each of these with some easy to get info from Envoy.
  tabs:
  - title: App - Envoy
    type: service
    hostname: app
    port: 19000
  - title: App - Cert
    type: code
    hostname: app
    path: /tmp/crt.txt
  - title: App - Authorize
    type: code
    hostname: app
    path: /tmp/payload.json
  - title: App
    type: terminal
    hostname: app
  - title: Consul UI
    type: service
    hostname: consul-server-0
    port: 8500
  - title: Website
    type: service
    hostname: app
    port: 80
  difficulty: basic
  timelimit: 900
checksum: "4343199991146368977"
